"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = __importDefault(require("./utils"));
const typescript_is_1 = require("typescript-is");
class Links {
    constructor(main) {
        this.main = main;
    }
    async get(fileID = this.main.persona.id, type) {
        const linksList = (await this.main.file.get(fileID)).links || [];
        if (type) {
            return linksList.find((links) => links.type === type);
        }
        else {
            return linksList;
        }
    }
    async post(links) {
        if (utils_1.default.check.valueLength(links) && typescript_is_1.equals(links, object => { var path = ["links"]; function _string(object) { ; if (typeof object !== "string")
            return { message: "validation failed at " + path.join(".") + ": expected a string", path: path.slice(), reason: { type: "string" } };
        else
            return null; } function sa__string_ea_13(object) { ; if (!Array.isArray(object))
            return { message: "validation failed at " + path.join(".") + ": expected an array", path: path.slice(), reason: { type: "array" } }; for (let i = 0; i < object.length; i++) {
            path.push("[" + i + "]");
            var error = _string(object[i]);
            path.pop();
            if (error)
                return error;
        } return null; } function _278_s(object) { ; if (typeof object !== "object" || object === null || Array.isArray(object))
            return { message: "validation failed at " + path.join(".") + ": expected an object", path: path.slice(), reason: { type: "object" } }; {
            if ("type" in object) {
                path.push("type");
                var error = _string(object["type"]);
                path.pop();
                if (error)
                    return error;
            }
            else
                return { message: "validation failed at " + path.join(".") + ": expected 'type' in object", path: path.slice(), reason: { type: "missing-property", property: "type" } };
        } {
            if ("tags" in object) {
                path.push("tags");
                var error = sa__string_ea_13(object["tags"]);
                path.pop();
                if (error)
                    return error;
            }
        } {
            if ("list" in object) {
                path.push("list");
                var error = sa__string_ea_13(object["list"]);
                path.pop();
                if (error)
                    return error;
            }
        } for (const key of Object.keys(object)) {
            if (key !== "type" && key !== "tags" && key !== "list")
                return { message: "validation failed at " + path.join(".") + ": " + ("superfluous property '" + key + "' in object"), path: path.slice(), reason: { type: "superfluous-property" } };
        } return null; } var error = _278_s(object); return error; })) {
            const file = await this.main.file.get(this.main.persona.id);
            if (!file.links) {
                file.links = [];
            }
            if (!file.links.find((lks) => lks.type === links.type)) {
                utils_1.default.object.removeEmpty(links);
                utils_1.default.accounts.sign(links, this.main.persona.privateKey);
                file.links.push(links);
            }
            else {
                throw Error('Link type already exists');
            }
            this.main.file.set(file);
            return links;
        }
        else {
            throw Error('Parameter error');
        }
    }
    async delete(type) {
        const file = await this.main.file.get(this.main.persona.id);
        const index = (file.links || []).findIndex((lks) => lks.type === type);
        if (index > -1) {
            const links = file.links[index];
            file.links.splice(index, 1);
            if (file.links.length === 0) {
                delete file.links;
            }
            this.main.file.set(file);
            return links;
        }
        else {
            throw Error('Link type does not exist');
        }
    }
    async patch(links) {
        if (utils_1.default.check.valueLength(links) && typescript_is_1.equals(links, object => { var path = ["links"]; function _string(object) { ; if (typeof object !== "string")
            return { message: "validation failed at " + path.join(".") + ": expected a string", path: path.slice(), reason: { type: "string" } };
        else
            return null; } function sa__string_ea_13(object) { ; if (!Array.isArray(object))
            return { message: "validation failed at " + path.join(".") + ": expected an array", path: path.slice(), reason: { type: "array" } }; for (let i = 0; i < object.length; i++) {
            path.push("[" + i + "]");
            var error = _string(object[i]);
            path.pop();
            if (error)
                return error;
        } return null; } function _278_s(object) { ; if (typeof object !== "object" || object === null || Array.isArray(object))
            return { message: "validation failed at " + path.join(".") + ": expected an object", path: path.slice(), reason: { type: "object" } }; {
            if ("type" in object) {
                path.push("type");
                var error = _string(object["type"]);
                path.pop();
                if (error)
                    return error;
            }
            else
                return { message: "validation failed at " + path.join(".") + ": expected 'type' in object", path: path.slice(), reason: { type: "missing-property", property: "type" } };
        } {
            if ("tags" in object) {
                path.push("tags");
                var error = sa__string_ea_13(object["tags"]);
                path.pop();
                if (error)
                    return error;
            }
        } {
            if ("list" in object) {
                path.push("list");
                var error = sa__string_ea_13(object["list"]);
                path.pop();
                if (error)
                    return error;
            }
        } for (const key of Object.keys(object)) {
            if (key !== "type" && key !== "tags" && key !== "list")
                return { message: "validation failed at " + path.join(".") + ": " + ("superfluous property '" + key + "' in object"), path: path.slice(), reason: { type: "superfluous-property" } };
        } return null; } var error = _278_s(object); return error; })) {
            const file = await this.main.file.get(this.main.persona.id);
            const linksList = file.links;
            const index = (linksList || []).findIndex((lks) => lks.type === links.type);
            if (index > -1) {
                linksList[index] = Object.assign(linksList[index], links);
                utils_1.default.object.removeEmpty(links);
                utils_1.default.accounts.sign(links, this.main.persona.privateKey);
                this.main.file.set(file);
                return linksList[index];
            }
            else {
                throw Error('Link type does not exist');
            }
        }
    }
}
exports.default = Links;
